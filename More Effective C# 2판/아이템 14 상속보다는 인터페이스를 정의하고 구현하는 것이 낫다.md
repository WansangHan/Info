## 상속
* 추상 베이스 클래스는 클래스 상속 계통에서 공통의 조상 역할을 한다.
* 추상 베이스 클래스는 상속 계통으로 연관된 타입들 사이의 공통적인 기능을 추상화하는 역할을 수행한다.
* is a
* 추상 베이스 클래스는 공통적인 동작을 기술하는 것뿐만 아니라 파생 타입에서 사용할 수 있는 구현부를 포함할 수도 있어서 데이터 멤버, 메서드, 가상 메서드의 구현부, 속성, 이벤트, 인덱서 등을 지정할 수 있다.
* 추상 베이스 클래스를 통해 공통 기능을 제공하면 파생 클래스에서 이를 재사용 할 수 있다.
* 인터페이스와는 달리 virtual nonvirtual abstract 등을 가리지 않고 어떤 요소든 사용할 수 있다.
* 구현 재사용의 이점
    * 베이스 클래스에 메서드를 추가하면 모든 파생 클래스가 자동적, 암묵적으로 이를 사용할 수 있으므로 개선된다고 볼 수 있다.
* 배포 이후에도 기능을 확장할 수 있으며, 이렇게 확장된 내용은 모든 파생 클래스에 즉각 반영된다.

## 인터페이스
* 특정 기능과 관련된 연관 메서드를 정의하고 타입이 이를 구현하도록 하는 방법이다.
* 설계 계약을 확정하는 방법이기도 하다.
* behave like
* 기능의 집합을 정의한다.
* 인터페이스 안에는 메서드, 속성, 인덱서, 이벤트 등 무엇이든 포함할 수 있어서, 일종의 틀을 만들 수 있다.
* 인터페이스를 구현하는 비추상 타입은 인터페이스에 정의된 모든 요소를 반드시 구현해야 한다.
* 개발자는 재사용 가능한 동작을 찾아 인터페이스로 구분할 수 있으며, 매개변수나 반환값의 타입으로도 인터페이스를 사용할 수 있다.
* 인터페이스를 사용하면 코드의 재사용성이 개선된다.
    * 연관성이 없는 타입들도 동일 인터페이스를 구현하기만 하면 동일하게 사용할 수 있기 때문이다.
* 이미 개발된 베이스 클래스를 확장하는 것 보다 인터페이스를 구현하는 쪽이 좀 더 수월하다.
* 인터페이스는 구현을 포함할 수 없으며 구체적인 데이터 멤버를 지닐 수도 없다.
    * 인터페이스는 이를 구현하는 타입의 계약을 선언하기 위한 것이기 때문이다.
    * 필요하다면 특정 인터페이스에 대하여 확장 메서드를 정의할 수도 있다. (static class의 statc 함수)
* 인터페이스에 멤버를 추가하면 해당 인터페이스를 구현한 모든 클래스를 손상시킨다.
    * 새로 추가한 메서드를 구현하지 않았으니 컴파일도 되지 않는다.
    * 기존 코드에 영향을 주지 않으면서 인터페이스에 새로운 기능을 추가해야 한다면 새로운 인터페이를 정의하면서, 기존 인터페이스를 상속하도록 하면 된다.(????)
* 한 번 배포되고 나면 그 이후에 변경될 수 없다.
* 인터페이스를 매개변수로 사용하는 메서드를 작성하는 편이 훨씬 일반적이면서 재사용하기도 쉽다.
* 클래스 타입으로 객체를 노출하게 되면, 이 클래스가 가지고있는 모든 기능을 노출하게 된다.
    * 인터페이스를 사용하면 사용하제에 허용할 동작을 선택적으로 노출할 수 있다.
* 아무런 연관성이 없는 타입들도 동일한 인터페이스를 구현할 수 있다.
    * 연관성이 없는 타입들에 대해서도 동일한 메서드를 이용하여 작업을 처리할 수 있으므로, 프로그래밍을 단순화 할 수 있다.
* 구조체를 사용할 때 발생하는 언박싱의 단점을 보완할 수 있다.(???)
    * 구조체를 하나의 박스에 두면 해당 박스는 구조체가 지원하는 모든 인터페이스를 지원하게 된다.
    * 해당 구조체를 인터페이스 참조를 통해 접근하면 객체에 접근하기 위해 구조체를 언박싱하지 않아도 된다.

## 상속 & 인터페이스
* 두 방식을 섞어서 사용하면 다중 인터페이스를 지원하면서 동시에 구현부를 재사용하도록 코드를 작성 할 수 있다.