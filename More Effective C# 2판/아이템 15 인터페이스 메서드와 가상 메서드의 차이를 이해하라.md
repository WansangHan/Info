## 가상 메서드
* 베이스 클래스의 추상 멤버를 구현하려면 반드시 가상화가 필요하다.
* 함수를 선언할 때 new를 덧붙이면 부모 함수를 숨겨버리게 된다.
    * 부모 클래스로 인스턴스를 만든경우 여전히 호출할 수 있다.

## 인터페이스 메서드
* 인터페이스 메서드를 구현할 때 굳이 가상화가 필요하지 않다.
    * 가상화 할 수 있긴 하다.
* 인터페이스도 구현부를 작성할 수 있다.
    * 훅을 만들면 된다.(??)

## 가상 & 인터페이스
* 상위클래스가 인터페이스를 구현하고 있고, 이 클래스를 상속하여 인터페이스를 다시 구현해야 한다고 생각해보자.
    * 컴파일러는 이 클래스에서 구현한 멤버가 인터페이스의 어느 멤버와 대응하는지를 결정해야 한다.
        * 이 때 명시적으로 인터페이스를 구현하면 그렇지 않은 경우보다 앞서 대응 관계가 설정된다.
        * 인터페이스 내에서 해당 멤버를 찾지 못한다면, 이번에는 베이스 타입의 멤버 중 접근 가능한 멤버가 후보가 된다.
        * 가상 멤버와 추상 멤버는 자신을 재정의한 타입이 아닌 자신을 선언한 타입의 멤버로 간주된다는 것을 기억하자.
* 인터페이스를 만들고, 베이스 클래스에서 이를 구현한 후, 파생 클래스에서 동작을 수정하는 방식을 원할 것이다.
    * 베이스 클래스의 멤버에 접근할 수 없다면 파생클래스에서 인터페이스를 재구현하는 방법이 있다.
        * 인터페이스가 추가되면 파생 클래스의 동작이 달라진다. 그 결과 인터페이스의 함수는 파생 클래스에서 구현한 버전을 사용하게 된다.
            * 베이스 클래스 버전은 여전히 베이스 클래스의 참조를 통해 접근할 수 있다.
                * 베이스 클래스를 수정하여 해당 인터페이스 메서드를 가상으로 선언하게 하는 방법으로 해결할 수 있다.(?)
        * 순수 가상 함수를 사용하는 방법이 더 마음에 든다면 인터페이스를 사용한 클래스를 수정하면 된다.
            * 인터페이스 내의 메서드를 실제로 구현하지 않으면서도, 인터페이스를 구현한 것 처럼 하는 것이다.
            * 인터페이스 내의 메서드에 대하여 abtract를 지정하는 것은 이 클래스를 상속한 클래스는 반드시 이 메서드를 재정의 해야 함을 선언하는 것과 같다.
                * 메서드를 구현할 책임은 각 파생 클래스로 미루는 것이다.
    * 인터페이스를 구현할 때 파생 클래스에서 가상 메서드를 호출하도록 하는 방법도 있다.
        * 이 방식을 사용하면 인터페이스 구현과 가상 함수 재정의 사이의 관계가 복잡해진다.
        * 명시적으로 인터페이스를 구현하는 방식은 실제로 이 인터페이스보다 더 나은 인터페이스가 있어서, 더 이상 이전 인터페이스를 쓰지 않도록 하기 위한 방법이다.
    * 베이스 클래스에서 인터페이스들의 기본 구현부를 제공하고, 파생 클래스에서 이 인터페이스를 구현할 것이라고 선언하는 방법도 있다.
        * 베이스 클래스가 구현부를 제공하기 때문에 파생 클래스에서 인터페이스를 명시적으로 구현할 필요가 없다.