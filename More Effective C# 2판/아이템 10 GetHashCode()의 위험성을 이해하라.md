## GetHashCode()
* 해시 기반 컬렉션에서 키의 해시 값을 정의 할 때 사용된다.
    * Hashset, Dictionary
* .Net에서는 모든 객체가 해시 코드를 가지며, 그 값은 GetHashCode에 의헤서 결정된다.

## GetHashCode() 함수의 문제점
* 참조의 타입에서는 겨우 동작은 하지만 비효율적이다.
* 값 타입에서는 베이스 클래스의 버전이 정확하지 않을 때가 있다.
    * 변경 불가능하도록 작성해야 한다.
* 효율적이면서 정확하게 동작하도록 코드를 작성하는 게 불가능 할 수도 있다.

## GetHashCode() 오버로드 시 규칙
* 두 객체가 같다면(Equals() 인스턴스 메서드로 비교 시) 동일한 해시값을 생성해야 한다. 그렇지 않으면 컬렉션에서 객체를 찾는 데 해시 코드를 사용할 수 없다.
    * System.Object
        * System.Object의 operator==()는 객체 ID를 비교하고 GetHashCode()는 객체의 ID를 반환한다.
        * Equals()를 재정의 하였다면 첫 번째 규칙을 어기지 않기 위해서 GetHashCode()도 재정의해야 한다.
    * System.ValueType
        * System.ValueType.GetHashCode()는 타입에 정의된 첫 번째 필드의 해시 코드를 반환하도록 구현되었다.
        * 값 타입의 경우 대부분의 상황에서 이 규칙을 준수하지만, 참조 타입처럼 규칙을 꺨 수도 있다.
            * 첫 번째 필드를 타입의 동일성 테스트에 사용하지 않으면 이 규칙을 위반하게 되고, GetHashCode를 망가트린다.
* 모든 객체 a에 대해 a.GetHashCode()sms 인스턴스 불변이어야 한다. a의 어떤 메서드를 호출하였든 a.GetHashCode()는 항상 같은 값을 반환해야 한다. 그래야 객체가 올바른 버킷에 담겨있다는 것을 보장할 수 있다.
    * System.Object
        * 객체가 생성된 후에는 해시 코드가 변경되지 않는다.
    * System.ValueType
        * 첫 번째 필드가 변경 불가능한 타입일 때만 성립한다.
* 해시 함수는 자주 사용되는 입력값들에 대해서 균일하게 분포된 정숫값을 생성해야 한다. 이상적으로라면 값이 널리 분포되어야 하며, 특정 값 위주로 비슷한 값이 여러번 반환되어서는 안된다. 그래야 컬렉션의 효율이 높아진다.
    * System.Object
        * 비교적 잘 지키고 있다.
    * System.ValueType
        * 첫 번쨰 필드가 어떤 타입인 지, 그리고 어떻게 사용되는지에 달려있다.

## 더 나은 해시 코드를 생성하기 위한 제약
* Equals()에 의해 2개의 객체가 같으면 두 객체는 동일한 해시값을 반환해야 한다.
    * 해시 코드를 생성하기 위해 사용한 속성과 데이터값 모두가 타입의 동일성 검사에서도 사용되어야 한다.
    * 동일성 확인 시에는 해시 코드 계산에 쓰이지 않은 필드를 사용할 수 도 있다.
        * System.ValueType가 기본적으로 이렇게 동작한다.
        * 이 접근법은 종종 세번쨰 규칙을 위반하곤 한다.
        * 따라서 두 계산에 같은 데이터 요소들을 쓰는 것이 좋다.
* 규칙 2를 해결하는 유일한 방법은 객체의 변경할 수 없는 속성이나 값에 기초하여 해시 코드를 생성하도록 메서드를 정의하는 것이다.
    * System.Object는 변경되지 않는 객체 ID를 이용하여 이 규칙을 준수한다.
* 규칙 3의 준수 여부는 온전히 사용자 정의 타입에 달려있다.
    * 가장 널리 사용되는 알고리즘은 해당 타입 내의 모든 필드로부터 해시 코드를 가져와서 XOR 연산을 수행하는 것이다.
        * 단 변경 가능 필드는 이 계산에서 제외해야 한다.
        * 이 알고리즘은 서로 연관성이 낮은 경우에 효율적으로 동작한다.