## 익명 타입이나 튜플을 사용해야하는 이유
* 클래스와 구조체가 강력한 도구임에는 분명하지만 간단한 기능을 구현하려는 경우에도 복잡한 규약이 필요하다.
    * 익명 타입이나 튜플처럼 간단한 기능을 사용하는 편이 코드 가독성에 유리하다.

## 익명 타입
* 컴파일러가 생성하는 변경 불가능한 참조 타입
* 작성하려면 새로운 변수를 선언하고 필요한 필드를 \{\} 안에 정의한다.

### 익명 타입의 장점
* 생성자, get 속성을 자동으로 만들어준다.
    * 작성해야하는 코드가 줄어든다
    * 이 과정에서 컴파일러의 실수가 없다.
    * 검토해야할 코드도 줄어든다.
* 변환 메서드에 대입할수 있다.(????)
* 알고리즘을 수행할 때 각 단계의 결과를 임시 저장하기 위해 사용할 수 있다.
* 제네릭 메서드와 람다 표현식을 사용하면 익명 타입의 객체를 다양한 형태로 얼마든지 변경할 수 있다.(????)
* 네임 스페이스를 안써도 된다.
* 익명 타입은 메서드 내에서만 유효하다.
    * 해당 익명 타입이 이를 정의한 메서드 내에서만 쓰인다는 것을 명확히 해주는 효과도 있다.
* 객체 초기화 구문을 지원하는 변경 불가능한 타입을 만드는 유일한 방법이다.
* 런타임 비용이 생각보다 크지 않다.
    * 똑같은 익명 타입을 요청하면 이전에 만든 익명 타입을 재사용한다.
        * 동일한 어셈블리 내에 선언이 되어야 한다.
        * 속성과 타입이 일치해야 하며 같은 순서로 선언되어야 한다.
* 동일성 검사를 할 때 값의 내용을 기반으로 하기 때문에 복합키로 사용할 수 있다.

### 익명 타입의 단점
* 타입의 이름을 알 수 없으므로 이 타입으로 매개변수를 전달할 수도 없고, 반환값의 타입으로도 사용할 수 없다.
    * 하지만 자동으로 생성된 익명 타입과는 달리, 이 타입으로 생성한 객체나 시퀀스는 여전히 사용할 수 있는데, 해당 객체를 사용하는 메서드나 표현식을 익명 타입을 정의하고 있는 메서드 내에 정의하면 된다. 구체적으로 람다 표현식이나 익명 델리게이트를 메서드 내에 정의하고, 각각의 본문에서 앞서 생성한 익명 타입의 객체를 처리하도록 코드를 작성하는 것이다. 혹은 함수를 매개변수로 취하는 제네릭 메서드를 작성한 후, 익명 메서드와 익명 타입의 객체를 함께 이용하는 방법도 있다.(????)

## 튜플
* 변경 가능한 값 타입이다.
* 튜플을 인스턴스화 하면 완전히 새로운 타입을 생성하는 것이 아니라 ValueTuple 제네릭 구조체를 이용하여 닫힌 제네릭 타입을 생성한다.(????)
* 작성하려면 필요한 필드를 () 안에 정의한다.
* 동일성 확인 메서드와 비교 메서드들을 제공한다.
* ToString 메서드도 제공한다.
* 튜플에서는 객체들이 같은 타입인지를 결정할 때 이름 기반 타이핑이 아니라 구조적 타이핑을 사용한다. 즉 형태를 확인하여 타입이 같은지 확인한다.
* 필드의 이름은 초기화 때 지정된다.
    * 사용자가 변수를 선언할 때 명시적으로 저장할 수 있다.
    * 할당문의 오른쪽 튜플에서 사용한 이름이 암시적으로 좌측 튜플에 그대로 적용되기도 한다.
    * 할당문 좌우측의 튜플에 모두 명시적으로 필드의 이름을 지정하였다면 좌측 튜플의 이름이 사용된다.

## 익명 타입, 튜플을 고를 때 고려사항
* 튜플은 구조적 타이핑을 따르므로 메서드의 반환 타입이나 매개변수의 타입으로 사용하기에 적합하다.
* 익명 타입은 변경 불가능한 타입을 정의할 때나 컬렉션의 복합키로 사용하기 좋다.
* 튜플은 값의 장점을 모두 가지는 반면, 익명 타입은 참조 타입이 가지는 장점을 모두 가진다.